#include <mpi.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>

#define N 2000      // Tamanho da grade
#define T 1000      // Quantidade de iterações
#define D 0.1       // Coeficiente de coesão
#define DELTA_T 0.01
#define DELTA_X 1.0

// Function to check if number is power of 2
int isPowerOfTwo(int n) {
    return (n != 0) && ((n & (n - 1)) == 0);
}

void diff_eq(double **C, double **C_new, int localN, int gridDim, int row, int col, int numRows, int numCols) {
    MPI_Status status;
    int myId;
    MPI_Comm_rank(MPI_COMM_WORLD, &myId);

    // Calculate neighbors for 1xN grid
    int up = MPI_PROC_NULL;    // No up neighbor in 1xN grid
    int down = MPI_PROC_NULL;  // No down neighbor in 1xN grid
    int left = (col > 0) ? myId - 1 : MPI_PROC_NULL;
    int right = (col < numCols - 1) ? myId + 1 : MPI_PROC_NULL;

    for (int t = 0; t < T; t++) {
        // No need for barrier here
        double *send_col = (double *)malloc(localN * sizeof(double));
        double *recv_col = (double *)malloc(localN * sizeof(double));

        // Horizontal exchanges only (for 2 processes case)
        if (left != MPI_PROC_NULL) {
            for (int i = 0; i < localN; i++) {
                send_col[i] = C[i][1];
            }
            MPI_Sendrecv(send_col, localN, MPI_DOUBLE, left, 0,
                        recv_col, localN, MPI_DOUBLE, left, 0,
                        MPI_COMM_WORLD, &status);
            for (int i = 0; i < localN; i++) {
                C[i][0] = recv_col[i];
            }
        }

        if (right != MPI_PROC_NULL) {
            for (int i = 0; i < localN; i++) {
                send_col[i] = C[i][localN-2];
            }
            MPI_Sendrecv(send_col, localN, MPI_DOUBLE, right, 0,
                        recv_col, localN, MPI_DOUBLE, right, 0,
                        MPI_COMM_WORLD, &status);
            for (int i = 0; i < localN; i++) {
                C[i][localN-1] = recv_col[i];
            }
        }

        free(send_col);
        free(recv_col);

        // Equation
        double difmedio = 0.0;
        for (int i = 1; i < localN-1; i++) {
            for (int j = 1; j < localN-1; j++) {
                C_new[i][j] = C[i][j] + D * DELTA_T * (
                    (C[i-1][j] + C[i+1][j] + C[i][j-1] + C[i][j+1] - 4.0 * C[i][j])
                    / (DELTA_X * DELTA_X)
                );
                difmedio += fabs(C_new[i][j] - C[i][j]);
                C[i][j] = C_new[i][j];
            }
        }

        if (t % 100 == 0) {
            printf("Process %d - Iteração %d - diferença média=%g\n", 
                   myId, t, difmedio / ((localN - 2) * (localN - 2)));
            fflush(stdout);
        }
    }
}

int main(int argc, char *argv[]) {
    int myId, numProcs;
    MPI_Init(&argc, &argv);
    MPI_Comm_rank(MPI_COMM_WORLD, &myId);
    MPI_Comm_size(MPI_COMM_WORLD, &numProcs);

    // Verify we have power of 2 processes
    if (!isPowerOfTwo(numProcs)) {
        if (myId == 0) {
            printf("This program requires number of processes to be a power of 2\n");
        }
        MPI_Finalize();
        return 1;
    }

    int numRows, numCols;

    if(numProcs == 2){
        numRows = 1;
        numCols = 2;
    }

    if (myId == 0) {
        printf("Grid configuration: %dx%d processes\n", numRows, numCols);
    }

    // Calculate grid dimensions
    int gridDim = (int)sqrt(numProcs); // Assume square grid of processes
    // if (gridDim * gridDim != numProcs) {
    //     if (myId == 0) {
    //         printf("Number of processes must be a perfect square\n");
    //     }
    //     MPI_Finalize();
    //     return 1;
    // }

    // Calculate process grid position
    int row = myId / numCols;
    int col = myId % numCols;

    // Calculate local grid size
    int localN_height = (N / numRows);
    int localN_width = (N / numCols);
    int localN = (N / numRows) + 2;     // Addd ghost cells

    int lineStart = row * localN_height;
    int colStart = col * localN_width;

    printf("Process %d (%d,%d) handling region [%d:%d, %d:%d]\n",
           myId, row, col, 
           lineStart, lineStart + localN_height - 1,
           colStart, colStart + localN_width - 1);
    fflush(stdout);

    // Initialize matrices
    double **C = (double **)malloc(localN * sizeof(double *));
    double **C_new = (double **)malloc(localN * sizeof(double *));
    
    if (C == NULL || C_new == NULL) {
        fprintf(stderr, "Memory allocation failed\n");
        MPI_Abort(MPI_COMM_WORLD, 1);
        return 1;
    }

    for (int i = 0; i < localN; i++) {
        C[i] = (double *)calloc(localN, sizeof(double));
        C_new[i] = (double *)calloc(localN, sizeof(double));
        if (C[i] == NULL || C_new[i] == NULL) {
            fprintf(stderr, "Memory allocation failed\n");
            MPI_Abort(MPI_COMM_WORLD, 1);
            return 1;
        }
    }

    // Find center and initialize
    int centerGlobal = N/2;
    if ((centerGlobal >= lineStart && centerGlobal < lineStart + localN - 2) &&
        (centerGlobal >= colStart && centerGlobal < colStart + localN - 2)) {
        int localI = (centerGlobal - lineStart) + 1;
        int localJ = (centerGlobal - colStart) + 1;
        C[localI][localJ] = 1.0;
        printf("Process %d initializes center at position [%d][%d]\n", myId, localI, localJ);
        fflush(stdout);
    }

    MPI_Barrier(MPI_COMM_WORLD);

    // Run diffusion equation
    diff_eq(C, C_new, localN, gridDim, row, col, gridDim, gridDim);

    MPI_Barrier(MPI_COMM_WORLD);

    // Prepare for gathering results
    int localSize = (N/gridDim) * (N/gridDim);
    double *localData = (double *)malloc(localSize * sizeof(double));
    double *globalData = NULL;

    if (myId == 0) {
        globalData = (double *)malloc(N * N * sizeof(double));
        if (globalData == NULL) {
            fprintf(stderr, "Failed to allocate global data array\n");
            MPI_Abort(MPI_COMM_WORLD, 1);
            return 1;
        }
    }

    // Copy local data without ghost cells
    int idx = 0;
    for (int i = 1; i < localN-1; i++) {
        for (int j = 1; j < localN-1; j++) {
            localData[idx++] = C[i][j];
        }
    }

    // Gather results
    MPI_Gather(localData, localSize, MPI_DOUBLE,
               globalData, localSize, MPI_DOUBLE,
               0, MPI_COMM_WORLD);

    // Process 0 saves results
    if (myId == 0) {
        FILE *fp = fopen("matriz_MPI_output.txt", "w");
        if (fp == NULL) {
            printf("Error opening output file\n");
        } else {
            for (int p = 0; p < numProcs; p++) {
                int pRow = p / gridDim;
                int pCol = p % gridDim;
                int baseI = pRow * (N/gridDim);
                int baseJ = pCol * (N/gridDim);
                int offset = p * localSize;

                for (int i = 0; i < N/gridDim; i++) {
                    for (int j = 0; j < N/gridDim; j++) {
                        double val = globalData[offset + i * (N/gridDim) + j];
                        if (val >= 0.0001) {
                            fprintf(fp, "i:%d j:%d Matriz:%f ", 
                                    baseI + i, baseJ + j, val);
                        }
                    }
                }
            }
            fclose(fp);

            // Find center value in global data
            int centerProc = (N/2)/(N/gridDim) * gridDim + (N/2)/(N/gridDim);
            int localOffset = ((N/2) % (N/gridDim)) * (N/gridDim) + ((N/2) % (N/gridDim));
            printf("\nConcentração final no centro: %.6f\n", 
                   globalData[centerProc * localSize + localOffset]);
        }
    }

    // Cleanup
    free(localData);
    if (myId == 0) {
        free(globalData);
    }

    for (int i = 0; i < localN; i++) {
        free(C[i]);
        free(C_new[i]);
    }
    free(C);
    free(C_new);

    MPI_Finalize();
    return 0;
}